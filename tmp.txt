[{"id": "0", "repo": "https://github.com/v8/v8", "commit_id": "6e586b48906cc056057fb00c4590af3b8bf23ded", "commit_message": "[sampler] Fix data race in Sampler::DoSample\n\nIn Sampler::DoSample, we only guard SignalHandler::Installed before\nand Sampler::Stop may happen at the same time, which may cause SIGPROF\nsignal handler was already restored before SIGPROF was emit and trigger\nprofiling timer expired. This CL changes Sampler::DoSample to use\nSignalHandler::mutex() to guard the entire function and also change\nthe mutex to recursive mutex.\n\nBug: v8:12838\nChange-Id: I5195742ecdbade342986755233840d7be5d83c62\nReviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3616429\nReviewed-by: Camillo Bruni <cbruni@chromium.org>\nCommit-Queue: \u738b\u6fb3 <wangao.james@bytedance.com>\nCr-Commit-Position: refs/heads/main@{#80308}", "label": 1, "jira_ticket_list": [], "github_issue_list": [], "commit": {"author_name": "V8 LUCI CQ", "created_date": "Mon, 02 May 2022 14:40:44 +0000", "files": [{"file_name": "src/libsampler/sampler.cc", "patch": "@@ -310,20 +310,23 @@ class Sampler::PlatformData {\n class SignalHandler {\n  public:\n   static void IncreaseSamplerCount() {\n-    base::MutexGuard lock_guard(mutex_.Pointer());\n+    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n     if (++client_count_ == 1) Install();\n   }\n \n   static void DecreaseSamplerCount() {\n-    base::MutexGuard lock_guard(mutex_.Pointer());\n+    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n     if (--client_count_ == 0) Restore();\n   }\n \n   static bool Installed() {\n-    base::MutexGuard lock_guard(mutex_.Pointer());\n+    // mutex_ will also be used in Sampler::DoSample to guard the state below.\n+    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n     return signal_handler_installed_;\n   }\n \n+  static v8::base::RecursiveMutex* mutex() { return mutex_.Pointer(); }\n+\n  private:\n   static void Install() {\n     struct sigaction sa;\n@@ -349,13 +352,15 @@ class SignalHandler {\n   static void HandleProfilerSignal(int signal, siginfo_t* info, void* context);\n \n   // Protects the process wide state below.\n-  static base::LazyMutex mutex_;\n+  static base::LazyRecursiveMutex mutex_;\n   static int client_count_;\n   static bool signal_handler_installed_;\n   static struct sigaction old_signal_handler_;\n };\n \n-base::LazyMutex SignalHandler::mutex_ = LAZY_MUTEX_INITIALIZER;\n+base::LazyRecursiveMutex SignalHandler::mutex_ =\n+    LAZY_RECURSIVE_MUTEX_INITIALIZER;\n+\n int SignalHandler::client_count_ = 0;\n struct sigaction SignalHandler::old_signal_handler_;\n bool SignalHandler::signal_handler_installed_ = false;\n@@ -568,6 +573,7 @@ void Sampler::Stop() {\n #if defined(USE_SIGNALS)\n \n void Sampler::DoSample() {\n+  base::RecursiveMutexGuard lock_guard(SignalHandler::mutex());\n   if (!SignalHandler::Installed()) return;\n   DCHECK(IsActive());\n   SetShouldRecordSample();\n", "status": "modify", "additions": 11, "deletions": 5, "changes": 16}]}}]